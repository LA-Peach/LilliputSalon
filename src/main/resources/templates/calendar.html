<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="_csrf" th:content="${_csrf.token}">
	<meta name="_csrf_header" th:content="${_csrf.headerName}">
    
    <title>Salon Calendar</title>
    <link rel="stylesheet" href="/css/lilliputSalon.css" />

    <style>
        #calendar {
            max-width: 1100px;
            margin: 20px auto;
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: var(--glass-shadow);
        }
    </style>
</head>

<body class="page-gradient">

<header>
    <div th:replace="~{fragments/owner-nav :: ownerNav}"></div>
</header>

<main>
    <h2 style="text-align:center; margin: 20px 0;">Salon Calendar</h2>

	<div style="
	  max-width:1100px;
	  margin:10px auto 12px;
	  display:flex;
	  align-items:center;
	  justify-content:space-between;
	  gap:12px;
	">
	  <!-- Left: availability toggles -->
	  <div id="availabilityToggles">
	    <strong>Show availability:</strong>
	  </div>
	
	  <!-- Right: create button -->
	  <button id="newApptBtn" class="btn-primary">
	    + New Appointment
	  </button>
	</div>
	
	<div id="calendar"></div>

</main>

<!-- FullCalendar Script -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.9/index.global.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
	
	const csrfToken = document.querySelector('meta[name="_csrf"]').content;
	const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;
	
	const createStartInput = document.getElementById('createStart');
	
	let selectedServiceIds = [];
	let selectedEditServiceIds = [];


	
	function toLocalDatetimeValue(date) {
		  const pad = n => String(n).padStart(2, '0');
		  return (
		    date.getFullYear() + '-' +
		    pad(date.getMonth() + 1) + '-' +
		    pad(date.getDate()) + 'T' +
		    pad(date.getHours()) + ':' +
		    pad(date.getMinutes())
		  );
	}

	
	let availabilityTogglesBuilt = false;
	
	const stylistVisibility = {};

    const calendarEl = document.getElementById('calendar');

    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',

        headerToolbar: {
            left:   'prev,next today',
            center: 'title',
            right:  'dayGridMonth,timeGridWeek,timeGridDay'
        },

        businessHours: [
            { daysOfWeek: [1,2,3,4,5], startTime: '09:00', endTime: '19:00' },
            { daysOfWeek: [6], startTime: '09:00', endTime: '17:00' }
        ],

        slotMinTime: '09:00:00',
        slotMaxTime: '19:00:00',

        editable: true,
        droppable: true,
        eventResizableFromStart: false,
        eventDurationEditable: false,
    


        eventSources: [

            // Appointments (already color-coded by backend)
            {
                url: '/calendar/events'
            },

            // Shifts (availability)
            {
            	  url: '/calendar/shifts',
            	  display: 'background', 
            	  editable: false,
            	  success(events) {
            	    if (!availabilityTogglesBuilt) {
            	      buildAvailabilityToggles(events);
            	      availabilityTogglesBuilt = true;
            	    }
            	  }
            	}




        ],
        
        eventDidMount(info) {
            const props = info.event.extendedProps;

            // reset in case FC reuses DOM nodes
            info.el.style.display = '';

            if (props?.type === 'shift' || props?.type === 'break') {
              if (stylistVisibility[props.stylistId] === false) {
                info.el.style.display = 'none';
              }
            }
          },

        eventTextColor: 'black',
        
        eventAllow(dropInfo, draggedEvent) {
        	  // Only block completed appointments
        	  return draggedEvent.extendedProps?.status !== 'Completed';
        	},




        eventDrop(info) {
            updateEvent(info);
        },
    
        eventClick: async function (info) {
        	  if (info.event.display === 'background') return;

        	  selectedEvent = info.event;

        	  const startInput = document.getElementById('modalStart');
        	  const endInput   = document.getElementById('modalEnd');

        	  startInput.value = toLocalDatetimeValue(info.event.start);

        	  endInput.value = info.event.end
        	    ? toLocalDatetimeValue(info.event.end)
        	    : '';


        	  // ðŸ”¥ LOAD SERVICES
        	  const res = await fetch('/services/api');
        	  const categories = await res.json();

        	  const preselected =
        	    info.event.extendedProps?.serviceIds || [];

        	  renderServicesForEdit(categories, preselected);

        	  document.getElementById('appointmentModal').style.display = 'flex';
        	},


        	

    });
    
    const createModal = document.getElementById('createModal');

    function openCreateModal() {
    	  const now = new Date();

    	  const createStartInput = document.getElementById('createStart');

    }



    function closeCreateModal() {
      createModal.style.display = 'none';
      document.getElementById('createStart').value = '';
    }

    createModal.addEventListener('click', e => {
      if (e.target === createModal) closeCreateModal();
    });

    document.getElementById('createCancelBtn')
      .addEventListener('click', closeCreateModal);

    
    
    let selectedEvent = null;

    const modal = document.getElementById('appointmentModal');
    
    modal.addEventListener('click', (e) => {
    	  if (e.target === modal) {
    	    modal.style.display = 'none';
    	    selectedEvent = null;
    	  }
    	});

    
    const modalTitle = document.getElementById('modalTitle');
    const modalTime = document.getElementById('modalTime');

    document.getElementById('closeBtn').addEventListener('click', () => {
    	  document.getElementById('appointmentModal').style.display = 'none';
    	  selectedEvent = null;
    	  document.getElementById('modalStart').value = '';
    	  document.getElementById('modalEnd').value = '';

    	});
    
    document.getElementById('newApptBtn')
    .addEventListener('click', async () => {

      await loadStylists();
      await loadServices();

      createModal.style.display = 'flex';

      setTimeout(() => {
        const now = new Date();

        document.getElementById('createStart').value =
        	toLocalDatetimeValue(now);
      }, 0);
  });




    document.getElementById('deleteBtn').onclick = async () => {
      if (!selectedEvent) return;

      if (!confirm('Delete this appointment?')) return;

      const res = await fetch(`/appointments/delete/${selectedEvent.id}`, {
    	  method: 'POST',
    	  headers: {
    	    [csrfHeader]: csrfToken
    	  }
    	});


      if (res.ok) {
        selectedEvent.remove(); // remove from calendar
        modal.style.display = 'none';
      } else {
        alert('Failed to delete appointment');
      }
    };
    
    document.getElementById('saveBtn').addEventListener('click', async () => {
    	  const start = document.getElementById('modalStart').value;
    	  const end   = document.getElementById('modalEnd').value;

    	  if (!start || !end) {
    	    alert('Start and end required');
    	    return;
    	  }
    	  
    	  if (new Date(end) <= new Date(start)) {
    		  alert('End time must be after start time');
    		  return;
    		}


    	 

    	  // âœï¸ EDIT MODE (existing logic)
    	  const res = await fetch('/calendar/update', {
    	    method: 'POST',
    	    headers: {
    	      'Content-Type': 'application/json',
    	      [csrfHeader]: csrfToken
    	    },
    	    body: JSON.stringify({
    	    	  id: selectedEvent.id,
    	    	  start: new Date(start).toISOString(),
    	    	  serviceIds: selectedEditServiceIds
    	    	})

    	  });

    	  const data = await res.json();
    	  if (data.status !== 'ok') {
    	    alert(data.message || 'Update failed');
    	    return;
    	  }

    	  calendar.refetchEvents();
    	  closeModal();
    	});

    async function loadStylists() {
    	  const res = await fetch('/web/stylists');
    	  const stylists = await res.json();

    	  const select = document.getElementById('createStylist');
    	  select.innerHTML = '<option value="">Select stylist</option>';

    	  stylists.forEach(s => {
    	    const opt = document.createElement('option');
    	    opt.value = s.userId;              // âœ… FIX HERE
    	    opt.textContent = s.firstName;
    	    select.appendChild(opt);
    	  });

    	  return stylists;
    	}
    
    async function loadServices() {
    	  const res = await fetch('/services/api');
    	  const services = await res.json();
    	  renderServices(services);
    	}


    document.getElementById('createSaveBtn')
    .addEventListener('click', async () => {

      const stylistId = Number(document.getElementById('createStylist').value);
      const start = createStartInput.value;

      const customerEmail  = document.getElementById('customerEmail').value;
      const guestFirstName = document.getElementById('guestFirstName').value;
      const guestLastName  = document.getElementById('guestLastName').value;
      const guestPhone     = document.getElementById('guestPhone').value;

      if (!stylistId || !start || selectedServiceIds.length === 0) {
        alert('Stylist, start time, and at least one service are required.');
        return;
      }

      const res = await fetch('/appointments/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          [csrfHeader]: csrfToken
        },
        body: JSON.stringify({
          stylistId,
          start: new Date(start).toISOString(),
          serviceIds: selectedServiceIds,
          customerEmail,
          guestFirstName,
          guestLastName,
          guestPhone
        })
      });

      const data = await res.json();

      if (data.status !== 'ok') {
        alert(data.message || 'Create failed');
        return;
      }

      calendar.refetchEvents();
      closeCreateModal();
    });



    
    function buildAvailabilityToggles(events) {
    	  const container = document.getElementById('availabilityToggles');
    	  container.innerHTML = '<strong>Show availability:</strong>';

    	  const seen = new Set();

    	  // ðŸ”‘ FIRST PASS: initialize visibility
    	  events.forEach(e => {
    	    const sid = e.extendedProps?.stylistId;
    	    if (!sid) return;

    	    if (stylistVisibility[sid] === undefined) {
    	      stylistVisibility[sid] = false; // default = hidden
    	    }
    	  });

    	  // ðŸ”‘ SECOND PASS: build checkboxes
    	  events.forEach(e => {
    	    const props = e.extendedProps;
    	    const sid = props?.stylistId;
    	    if (!sid || seen.has(sid)) return;

    	    seen.add(sid);

    	    const label = document.createElement('label');
    	    label.style.marginRight = '12px';

    	    const cb = document.createElement('input');
    	    cb.type = 'checkbox';
    	    cb.checked = false; // ðŸ”¥ force unchecked on load

    	    cb.addEventListener('change', () => {
    	      stylistVisibility[sid] = cb.checked;
    	      calendar.refetchEvents();
    	    });

    	    label.appendChild(cb);
    	    label.append(` ${props.stylistName}`);
    	    container.appendChild(label);
    	  });
    	}



    function updateEvent(info) {
    	  fetch('/calendar/update', {
    	    method: 'POST',
    	    headers: {
    	      'Content-Type': 'application/json',
    	      [csrfHeader]: csrfToken
    	    },
    	    body: JSON.stringify({
    	      id: info.event.id,
    	      start: info.event.start.toISOString()
    	      // âŒ DO NOT SEND end
    	    })
    	  })
    	  .then(res => res.json())
    	  .then(data => {
    	    if (data.status !== "ok") {
    	      alert(data.message || "Move rejected");
    	      info.revert();
    	    } else {
    	      calendar.refetchEvents();
    	    }
    	  })
    	  .catch(err => {
    	    console.error(err);
    	    info.revert();
    	  });
    	}

    
    function openEditModal(dateStr) {
    	  selectedEvent = null;
    	  isCreateMode = true;

    	  const modal = document.getElementById('appointmentModal');
    	  const modalStartInput = document.getElementById('modalStart');
    	  const modalEndInput   = document.getElementById('modalEnd');

    	  function ensureEditEndAfterStart() {
    	    if (!modalStartInput.value) return;

    	    const start = new Date(modalStartInput.value);
    	    let end = modalEndInput.value
    	      ? new Date(modalEndInput.value)
    	      : null;

    	    if (!end || end <= start) {
    	      const fixedEnd = new Date(start.getTime() + 30 * 60 * 1000);
    	      modalEndInput.value = toLocalDatetimeValue(fixedEnd);
    	    }
    	  }

    	  modalStartInput.addEventListener('change', ensureEditEndAfterStart);
    	  modalEndInput.addEventListener('change', ensureEditEndAfterStart);



    	  // Prefill start time
    	  startInput.value = dateStr.slice(0, 16);

    	  // Optional: default duration (1 hour)
    	  const startDate = new Date(dateStr);
    	  const endDate = new Date(startDate.getTime() + 60 * 60 * 1000);
    	  endInput.value = toLocalDatetimeValue(endDate);

    	  document.getElementById('modalTitle').textContent = 'New Appointment';

    	  // Enable inputs
    	  startInput.disabled = false;
    	  endInput.disabled   = false;
    	  document.getElementById('saveBtn').disabled = false;
    	  document.getElementById('deleteBtn').style.display = 'none';

    	  modal.style.display = 'flex';
    	}
    
    function updateComputedEnd(start, services) {
    	  const totalMinutes = services.reduce(
    	    (sum, s) => sum + s.typicalDurationMinutes, 0
    	  );

    	  const end = new Date(start.getTime() + totalMinutes * 60000);
    	  document.getElementById('modalEnd').value =
    		  toLocalDatetimeValue(end);

    	}
    
    function renderServices(categories) {
    	  const container = document.getElementById('serviceList');
    	  container.innerHTML = '';
    	  selectedServiceIds = [];

    	  categories.forEach(cat => {
    	    if (!cat.services || cat.services.length === 0) return;

    	    const catDiv = document.createElement('div');
    	    catDiv.className = 'service-category';

    	    const title = document.createElement('h4');
    	    title.textContent = cat.categoryName;
    	    catDiv.appendChild(title);

    	    const grid = document.createElement('div');
    	    grid.className = 'service-grid';

    	    cat.services.forEach(svc => {
    	      const btn = document.createElement('button');
    	      btn.type = 'button';
    	      btn.className = 'service-btn';
    	      btn.textContent = `${svc.name} (${svc.typicalDurationMinutes} min)`;

    	      btn.addEventListener('click', () => {
    	        btn.classList.toggle('selected');

    	        if (btn.classList.contains('selected')) {
    	          selectedServiceIds.push(svc.serviceId);
    	        } else {
    	          selectedServiceIds =
    	            selectedServiceIds.filter(id => id !== svc.serviceId);
    	        }

    	        // auto-update end time
    	        const startVal = createStartInput.value;
    	        if (startVal) {
    	          updateComputedEnd(
    	            new Date(startVal),
    	            cat.services.filter(s =>
    	              selectedServiceIds.includes(s.serviceId)
    	            )
    	          );
    	        }
    	      });

    	      grid.appendChild(btn);
    	    });

    	    catDiv.appendChild(grid);
    	    container.appendChild(catDiv);
    	  });
    	}
    
    function renderServicesForEdit(categories, preselectedIds) {
    	  const container = document.getElementById('editServiceList');
    	  container.innerHTML = '';
    	  selectedEditServiceIds = [...preselectedIds];

    	  categories.forEach(cat => {
    	    if (!cat.services || cat.services.length === 0) return;

    	    const catDiv = document.createElement('div');
    	    catDiv.className = 'service-category';

    	    const title = document.createElement('h4');
    	    title.textContent = cat.categoryName;
    	    catDiv.appendChild(title);

    	    const grid = document.createElement('div');
    	    grid.className = 'service-grid';

    	    cat.services.forEach(svc => {
    	      const btn = document.createElement('button');
    	      btn.type = 'button';
    	      btn.className = 'service-btn';
    	      btn.textContent = `${svc.name} (${svc.typicalDurationMinutes} min)`;

    	      if (preselectedIds.includes(svc.serviceId)) {
    	        btn.classList.add('selected');
    	      }

    	      btn.addEventListener('click', () => {
    	        btn.classList.toggle('selected');

    	        if (btn.classList.contains('selected')) {
    	          selectedEditServiceIds.push(svc.serviceId);
    	        } else {
    	          selectedEditServiceIds =
    	            selectedEditServiceIds.filter(id => id !== svc.serviceId);
    	        }

    	        const startVal = document.getElementById('modalStart').value;
    	        if (startVal) {
    	          updateComputedEnd(
    	            new Date(startVal),
    	            categories.flatMap(c => c.services)
    	              .filter(s => selectedEditServiceIds.includes(s.serviceId))
    	          );
    	        }
    	      });

    	      grid.appendChild(btn);
    	    });

    	    catDiv.appendChild(grid);
    	    container.appendChild(catDiv);
    	  });
    	}



    
    function closeModal() {
    	  document.getElementById('appointmentModal').style.display = 'none';
    	  selectedEvent = null;
    	  isCreateMode = false;

    	  document.getElementById('modalStart').value = '';
    	  document.getElementById('modalEnd').value = '';

    	  
    	  calendar.refetchEvents();
    	}
    
    const emailInput = document.getElementById('customerEmail');
    const resultsBox = document.getElementById('customerSearchResults');

    let searchTimer = null;

    emailInput.addEventListener('input', () => {
      const q = emailInput.value.trim();

      clearTimeout(searchTimer);

      if (q.length < 2) {
        resultsBox.style.display = 'none';
        resultsBox.innerHTML = '';
        return;
      }

      searchTimer = setTimeout(async () => {
        const res = await fetch(`/customers/search?q=${encodeURIComponent(q)}`);
        const customers = await res.json();

        resultsBox.innerHTML = '';

        if (customers.length === 0) {
          resultsBox.style.display = 'none';
          return;
        }

        customers.forEach(c => {
          const div = document.createElement('div');
          div.textContent = `${c.email} (${c.firstName} ${c.lastName})`;
          div.style.padding = '8px 12px';
          div.style.cursor = 'pointer';

          div.textContent = `${c.email} (${c.firstName} ${c.lastName})`;

          div.addEventListener('click', () => {
            // email
            emailInput.value = c.email;

            // autofill customer info
            document.getElementById('guestFirstName').value = c.firstName || '';
            document.getElementById('guestLastName').value  = c.lastName  || '';
            document.getElementById('guestPhone').value     = c.phone     || '';

            resultsBox.style.display = 'none';
          });


          resultsBox.appendChild(div);
        });

        resultsBox.style.display = 'block';
      }, 250); // debounce
    });

    

    


    calendar.render();
});




</script>



<div id="appointmentModal" class="modal-overlay" style="display:none;">
  <div class="modal-card glass-card">
    <h3 id="modalTitle"></h3>
    
    <div class="field-group">
	  <label>Services</label>
	  <div id="editServiceList"></div>
	</div>
    

    <div class="field-group">
      <label>Start</label>
      <input type="datetime-local" id="modalStart">
    </div>

    <div class="field-group">
      <label>End</label>
      <input type="datetime-local" id="modalEnd" disabled>
    </div>

    <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
      <button id="saveBtn" class="btn-primary" type="button">Save</button>
      <button id="deleteBtn" class="btn-danger" type="button">Delete</button>
      <button id="closeBtn" class="btn-secondary" type="button">Close</button>
    </div>
  </div>
</div>

<div id="createModal" class="modal-overlay" style="display:none;">
  <div class="modal-card glass-card">
    <h3>New Appointment</h3>
    
    <div class="field-group">
	  <label>Services</label>
	  <div id="serviceList"></div>
	</div>
    

    <div class="field-group">
      <label>Stylist</label>
      <select id="createStylist">
		  <option value="">Select stylist</option>
		</select>

    </div>
    
    <div class="field-group" style="position:relative;">
	  <label>Customer Email</label>
	  <input
	    type="email"
	    id="customerEmail"
	    placeholder="Search or enter email"
	    autocomplete="off"
	  >
	
	  <div id="customerSearchResults"
	       style="
	         position:absolute;
	         top:100%;
	         left:0;
	         right:0;
	         background:white;
	         border-radius:8px;
	         box-shadow:0 8px 20px rgba(0,0,0,.15);
	         z-index:1000;
	         display:none;
	         max-height:180px;
	         overflow-y:auto;
	       ">
	  </div>
	</div>

	
	<div class="field-group">
	  <label>First Name</label>
	  <input type="text" id="guestFirstName">
	</div>
	
	<div class="field-group">
	  <label>Last Name</label>
	  <input type="text" id="guestLastName">
	</div>
	
	<div class="field-group">
	  <label>Phone</label>
	  <input type="text" id="guestPhone">
	</div>
    

    <div class="field-group">
      <label>Start</label>
      <input type="datetime-local" id="createStart">
    </div>


    <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
      <button id="createSaveBtn" class="btn-primary" type="button">Create</button>
      <button id="createCancelBtn" class="btn-secondary" type="button">Cancel</button>
    </div>
  </div>
</div>



</body>
</html>
