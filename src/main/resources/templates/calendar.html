<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="_csrf" th:content="${_csrf.token}">
    <meta name="_csrf_header" th:content="${_csrf.headerName}">
    
    <title>Salon Calendar</title>
    <link rel="stylesheet" href="/css/lilliputSalon.css" />

    <style>
        #calendar {
            max-width: 1100px;
            margin: 20px auto;
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: var(--glass-shadow);
        }
    </style>
</head>

<body class="page-gradient">

<header>
    <div th:replace="~{fragments/owner-nav :: ownerNav}"></div>
</header>

<main>
    <h2 style="text-align:center; margin: 20px 0;">Salon Calendar</h2>

    <div style="max-width:1100px; margin:10px auto 12px; display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <div id="availabilityToggles">
            <strong>Show availability:</strong>
        </div>
        
        <button id="newApptBtn" class="btn-primary">+ New Appointment</button>
    </div>
    
    <div id="calendar"></div>
</main>

<!-- FullCalendar Script -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.9/index.global.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', async function () {
    
    // ========================================
    // STATE & CONFIGURATION
    // ========================================
    
    const csrfToken = document.querySelector('meta[name="_csrf"]').content;
    const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;
    
    const state = {
        selectedEvent: null,
        selectedServiceIds: [],
        selectedEditServiceIds: [],
        stylistVisibility: {},
        availabilityTogglesBuilt: false,
        serviceCache: null
    };
    
    state.serviceCache = null;
    
 // ========================================
 // PRELOAD SERVICES
 // ========================================
    (async () => {
        try {
            const res = await fetch('/services/api');
            state.serviceCache = await res.json();
        } catch (e) {
            console.error('Failed to preload services', e);
        }
    })();
    
    
    // ========================================
    // UTILITY FUNCTIONS
    // ========================================
    	
    async function loadServiceCache() {
	    if (state.serviceCache) return state.serviceCache;
	
	    const res = await fetch('/services/api');
	    state.serviceCache = await res.json();
	    return state.serviceCache;
	}

    
    function toLocalDatetimeValue(date) {
        const pad = n => String(n).padStart(2, '0');
        return (
            date.getFullYear() + '-' +
            pad(date.getMonth() + 1) + '-' +
            pad(date.getDate()) + 'T' +
            pad(date.getHours()) + ':' +
            pad(date.getMinutes())
        );
    }
    
    function computeEndFromServices(start, serviceIds, allCategories) {
        const allServices = allCategories.flatMap(c => c.services);
        const totalMinutes = allServices
            .filter(s => serviceIds.includes(s.serviceId))
            .reduce((sum, s) => sum + s.typicalDurationMinutes, 0);
        
        return new Date(start.getTime() + totalMinutes * 60000);
    }
    
    function hasOverlap({ stylistId, start, end }) {
    	  const events = calendar.getEvents();
    	  const allServices = state.serviceCache.flatMap(c => c.services);

    	  return events.some(evt => {
    	    if (evt.display === 'background') return false;

    	    // üîí stylist comparison (force number)
    	    if (Number(evt.extendedProps?.stylistId) !== Number(stylistId)) return false;

    	    if (!evt.start) return false;

    	    const existingStart = evt.start;

    	    // ‚úÖ COMPUTE EXISTING END FROM SERVICES
    	    let existingEnd = evt.end;

    	    if (!existingEnd) {
    	      const serviceIds = evt.extendedProps?.serviceIds || [];

    	      const totalMinutes = allServices
    	        .filter(s => serviceIds.includes(s.serviceId))
    	        .reduce((sum, s) => sum + s.typicalDurationMinutes, 0);

    	      if (!totalMinutes) return false;

    	      existingEnd = new Date(existingStart.getTime() + totalMinutes * 60000);
    	    }

    	    return start < existingEnd && end > existingStart;
    	  });
    	}
    
    function recomputeEditEndFromStart() {
        if (!state.serviceCache) return;

        const startVal = document.getElementById('modalStart').value;
        if (!startVal) return;

        const start = new Date(startVal);

        const services = state.serviceCache
            .flatMap(c => c.services)
            .filter(s => state.selectedEditServiceIds.includes(s.serviceId));

        if (services.length === 0) return;

        updateComputedEnd(start, services);
    }



    
    
    // ========================================
    // CALENDAR INITIALIZATION
    // ========================================
    
    const calendarEl = document.getElementById('calendar');
    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        
        allDaySlot: false,
        hiddenDays: [0],
        
        slotDuration: '00:15:00',
        snapDuration: '00:15:00',
        
        slotMinTime: '09:00:00',
        slotMaxTime: '19:00:00',
        
        headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },
        
        businessHours: [
            { daysOfWeek: [1,2,3,4,5], startTime: '09:00', endTime: '19:00' },
            { daysOfWeek: [6], startTime: '09:00', endTime: '17:00' }
        ],
        
        
        nowIndicator: true,
        expandRows: true,
        height: 'auto',
        
        editable: true,
        droppable: true,
        eventResizableFromStart: false,
        eventDurationEditable: false,
        eventTextColor: 'black',
        
        eventSources: [
            { url: '/calendar/events' },
            {
                url: '/calendar/shifts',
                display: 'background',
                editable: false,
                success(events) {
                    if (!state.availabilityTogglesBuilt) {
                        buildAvailabilityToggles(events);
                        state.availabilityTogglesBuilt = true;
                    }
                }
            }
        ],
        
        eventDidMount(info) {
            const props = info.event.extendedProps;
            info.el.style.display = '';
            
            if (props?.type === 'shift' || props?.type === 'break') {
                if (state.stylistVisibility[props.stylistId] === false) {
                    info.el.style.display = 'none';
                }
            }
        },
        
        eventAllow(dropInfo, draggedEvent) {

            // üö´ completed appointments never move
            if (draggedEvent.extendedProps?.status === 'Completed') {
                return false;
            }

            const start = dropInfo.start;
            const end   = dropInfo.end;

            if (!start || !end) return false;

            const day = start.getDay(); // 0=Sun, 6=Sat
            const startHour = start.getHours() + start.getMinutes() / 60;
            const endHour   = end.getHours() + end.getMinutes() / 60;

            // ‚è∞ weekday hours
            if (day >= 1 && day <= 5) {
                if (startHour < 9 || endHour > 19) return false;
            }

            // ‚è∞ saturday hours
            if (day === 6) {
                if (startHour < 9 || endHour > 17) return false;
            }

            // üö´ sunday (extra safety even though hidden)
            if (day === 0) return false;

            return true;
        },


        
        eventDrop(info) {
            handleEventUpdate(info);
        },
        
        eventClick: async function(info) {
            if (info.event.display === 'background') return;
            await handleEventClick(info);
        }
    });
    
    
    // ========================================
    // EVENT HANDLERS
    // ========================================
    
    async function handleEventClick(info) {
        state.selectedEvent = info.event;
        
        const startInput = document.getElementById('modalStart');
        const endInput = document.getElementById('modalEnd');
        
        startInput.value = toLocalDatetimeValue(info.event.start);
        endInput.value = info.event.end ? toLocalDatetimeValue(info.event.end) : '';
        
        const categories = state.serviceCache;
        state.serviceCache = categories;
        const preselected = info.event.extendedProps?.serviceIds || [];
        
        renderServicesForEdit(categories, preselected);
        recomputeEditEndFromStart();
        document.getElementById('appointmentModal').style.display = 'flex';
    }
    
    async function handleEventUpdate(info) {
        try {
            const res = await fetch('/calendar/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    [csrfHeader]: csrfToken
                },
                body: JSON.stringify({
                    id: info.event.id,
                    start: info.event.start.toISOString()
                })
            });
            
            const data = await res.json();
            
            if (!res.ok || data.status !== "ok") {
                alert(data.message || "Move rejected");
                info.revert();
                return;
            

            } else {
                calendar.refetchEvents();
            }
        } catch (err) {
            console.error(err);
            info.revert();
        }
    }
    
    async function handleSaveEdit() {
        const start = document.getElementById('modalStart').value;
        const end = document.getElementById('modalEnd').value;
        
        if (!start || !end) {
            alert('Start and end required');
            return;
        }
        
        if (new Date(end) <= new Date(start)) {
            alert('End time must be after start time');
            return;
        }
        
        const res = await fetch('/calendar/update', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                [csrfHeader]: csrfToken
            },
            body: JSON.stringify({
                id: state.selectedEvent.id,
                start: new Date(start).toISOString(),
                serviceIds: state.selectedEditServiceIds
            })
        });
        
        const data = await res.json();
        
        if (data.status !== 'ok') {
            alert(data.message || 'Update failed');
            return;
        }
        
        calendar.refetchEvents();
        closeEditModal();
    }
    
    async function handleDeleteAppointment() {
        if (!state.selectedEvent) return;
        if (!confirm('Delete this appointment?')) return;
        
        const res = await fetch(`/appointments/delete/${state.selectedEvent.id}`, {
            method: 'POST',
            headers: { [csrfHeader]: csrfToken }
        });
        
        if (res.ok) {
            state.selectedEvent.remove();
            document.getElementById('appointmentModal').style.display = 'none';
        } else {
            alert('Failed to delete appointment');
        }
    }
    
    async function handleCreateAppointment() {
        const stylistId = Number(document.getElementById('createStylist').value);
        const startVal = document.getElementById('createStart').value;
        
        if (!stylistId || !startVal || state.selectedServiceIds.length === 0) {
            alert('Stylist, start time, and at least one service are required.');
            return;
        }
        
        const start = new Date(startVal);
        const categories = state.serviceCache;
        const end = computeEndFromServices(start, state.selectedServiceIds, categories);
        
        if (calendar.getEvents().length === 0) {
        	  await calendar.refetchEvents();
        	}

        
        if (hasOverlap({ stylistId, start, end })) {
            alert('This appointment overlaps an existing appointment for this stylist.');
            return;
        }
        
        const response = await fetch('/appointments/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                [csrfHeader]: csrfToken
            },
            body: JSON.stringify({
                stylistId,
                start: start.toISOString(),
                serviceIds: state.selectedServiceIds,
                customerEmail: document.getElementById('customerEmail').value,
                guestFirstName: document.getElementById('guestFirstName').value,
                guestLastName: document.getElementById('guestLastName').value,
                guestPhone: document.getElementById('guestPhone').value
            })
        });
        
        const data = await response.json();
        
        if (data.status !== 'ok') {
            alert(data.message || 'Create failed');
            return;
        }
        
        calendar.refetchEvents();
        closeCreateModal();
    }
    
    
    // ========================================
    // UI MANAGEMENT
    // ========================================
    
    function buildAvailabilityToggles(events) {
        const container = document.getElementById('availabilityToggles');
        container.innerHTML = '<strong>Show availability:</strong>';
        const seen = new Set();
        
        // Initialize visibility
        events.forEach(e => {
            const sid = e.extendedProps?.stylistId;
            if (!sid) return;
            if (state.stylistVisibility[sid] === undefined) {
                state.stylistVisibility[sid] = false;
            }
        });
        
        // Build checkboxes
        events.forEach(e => {
            const props = e.extendedProps;
            const sid = props?.stylistId;
            if (!sid || seen.has(sid)) return;
            
            seen.add(sid);
            
            const label = document.createElement('label');
            label.style.marginRight = '12px';
            
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = false;
            
            cb.addEventListener('change', () => {
                state.stylistVisibility[sid] = cb.checked;
                calendar.refetchEvents();
            });
            
            label.appendChild(cb);
            label.append(` ${props.stylistName}`);
            container.appendChild(label);
        });
    }
    
    async function loadStylists() {
        const res = await fetch('/web/stylists');
        const stylists = await res.json();
        
        const select = document.getElementById('createStylist');
        select.innerHTML = '<option value="">Select stylist</option>';
        
        stylists.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.userId;
            opt.textContent = s.firstName;
            select.appendChild(opt);
        });
        
        return stylists;
    }
    
    function loadServices() {
        renderServices(state.serviceCache);
    }

    
    

    
    function renderServices(categories) {
        const container = document.getElementById('serviceList');
        container.innerHTML = '';
        state.selectedServiceIds = [];
        
        categories.forEach(cat => {
            if (!cat.services || cat.services.length === 0) return;
            
            const catDiv = document.createElement('div');
            catDiv.className = 'service-category';
            
            const title = document.createElement('h4');
            title.textContent = cat.categoryName;
            catDiv.appendChild(title);
            
            const grid = document.createElement('div');
            grid.className = 'service-grid';
            
            cat.services.forEach(svc => {
                const btn = createServiceButton(svc, () => {
                    const startVal = document.getElementById('createStart').value;
                    if (startVal) {
                        updateComputedEnd(
                            new Date(startVal),
                            cat.services.filter(s => state.selectedServiceIds.includes(s.serviceId))
                        );
                    }
                });
                grid.appendChild(btn);
            });
            
            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }
    
    function renderServicesForEdit(categories, preselectedIds) {
        const container = document.getElementById('editServiceList');
        container.innerHTML = '';
        state.selectedEditServiceIds = [...preselectedIds];
        
        categories.forEach(cat => {
            if (!cat.services || cat.services.length === 0) return;
            
            const catDiv = document.createElement('div');
            catDiv.className = 'service-category';
            
            const title = document.createElement('h4');
            title.textContent = cat.categoryName;
            catDiv.appendChild(title);
            
            const grid = document.createElement('div');
            grid.className = 'service-grid';
            
            cat.services.forEach(svc => {
                const btn = createEditServiceButton(svc, preselectedIds, categories);
                grid.appendChild(btn);
            });
            
            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }
    
    function createServiceButton(svc, onUpdate) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'service-btn';
        btn.textContent = `${svc.name} (${svc.typicalDurationMinutes} min)`;
        
        btn.addEventListener('click', () => {
            btn.classList.toggle('selected');
            
            if (btn.classList.contains('selected')) {
                state.selectedServiceIds.push(svc.serviceId);
            } else {
                state.selectedServiceIds = state.selectedServiceIds.filter(id => id !== svc.serviceId);
            }
            
            onUpdate();
        });
        
        return btn;
    }
    
    function createEditServiceButton(svc, preselectedIds, categories) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'service-btn';
        btn.textContent = `${svc.name} (${svc.typicalDurationMinutes} min)`;
        
        if (preselectedIds.includes(svc.serviceId)) {
            btn.classList.add('selected');
        }
        
        btn.addEventListener('click', () => {
            btn.classList.toggle('selected');
            
            if (btn.classList.contains('selected')) {
                state.selectedEditServiceIds.push(svc.serviceId);
            } else {
                state.selectedEditServiceIds = state.selectedEditServiceIds.filter(id => id !== svc.serviceId);
            }
            
            const startVal = document.getElementById('modalStart').value;
            if (startVal) {
                updateComputedEnd(
                    new Date(startVal),
                    categories.flatMap(c => c.services)
                        .filter(s => state.selectedEditServiceIds.includes(s.serviceId))
                );
            }
        });
        
        return btn;
    }
    
    function updateComputedEnd(start, services) {
        if (!state.serviceCache) return;

        const totalMinutes = services.reduce(
            (sum, s) => sum + s.typicalDurationMinutes, 0
        );

        const end = new Date(start.getTime() + totalMinutes * 60000);
        document.getElementById('modalEnd').value = toLocalDatetimeValue(end);
    }

    
    
    // ========================================
    // MODAL MANAGEMENT
    // ========================================
    
    async function openCreateModal() {
        await loadStylists();
        await loadServices();
        
        document.getElementById('createModal').style.display = 'flex';
        
        setTimeout(() => {
            const now = new Date();
            document.getElementById('createStart').value = toLocalDatetimeValue(now);
        }, 0);
    }
    
    function closeCreateModal() {
        document.getElementById('createModal').style.display = 'none';
        document.getElementById('createStart').value = '';
        state.selectedServiceIds = [];
    }
    
    function closeEditModal() {
        document.getElementById('appointmentModal').style.display = 'none';
        state.selectedEvent = null;
        document.getElementById('modalStart').value = '';
        document.getElementById('modalEnd').value = '';
        calendar.refetchEvents();
    }
    
    
    // ========================================
    // CUSTOMER SEARCH
    // ========================================
    
    function setupCustomerSearch() {
        const emailInput = document.getElementById('customerEmail');
        const resultsBox = document.getElementById('customerSearchResults');
        let searchTimer = null;
        
        emailInput.addEventListener('input', () => {
            const q = emailInput.value.trim();
            
            clearTimeout(searchTimer);
            
            if (q.length < 2) {
                resultsBox.style.display = 'none';
                resultsBox.innerHTML = '';
                return;
            }
            
            searchTimer = setTimeout(async () => {
                const res = await fetch(`/customers/search?q=${encodeURIComponent(q)}`);
                const customers = await res.json();
                
                resultsBox.innerHTML = '';
                
                if (customers.length === 0) {
                    resultsBox.style.display = 'none';
                    return;
                }
                
                customers.forEach(c => {
                    const div = document.createElement('div');
                    div.textContent = `${c.email} (${c.firstName} ${c.lastName})`;
                    div.style.padding = '8px 12px';
                    div.style.cursor = 'pointer';
                    
                    div.addEventListener('click', () => {
                        emailInput.value = c.email;
                        document.getElementById('guestFirstName').value = c.firstName || '';
                        document.getElementById('guestLastName').value = c.lastName || '';
                        document.getElementById('guestPhone').value = c.phone || '';
                        resultsBox.style.display = 'none';
                    });
                    
                    resultsBox.appendChild(div);
                });
                
                resultsBox.style.display = 'block';
            }, 250);
        });
    }
    
<<<<<<< HEAD
 	// ========================================
    // WALK-INS
    // ========================================
    	async function loadWalkInQueue() {
	    const res = await fetch('/walkins/queue');
	    const queue = await res.json();
	
	    const tbody = document.getElementById('walkInQueue');
	    tbody.innerHTML = '';
	
	    queue.forEach(w => {
	        const tr = document.createElement('tr');
	
	        tr.innerHTML = `
	            <td>${w.customerId ?? 'Guest'}</td>
	            <td>
		            ${(w.services || []).map(s => s.service?.name).join(', ')}
		          </td>

	            <td>${w.estimatedWaitMinutes} min</td>
	            <td>
	                <select data-id="${w.walkInId}" class="assignStylist"></select>
	            </td>
	            <td>
	                <button class="btn-primary startWalkIn"
	                        data-id="${w.walkInId}">
	                    Start
	                </button>
	            </td>
	        `;
	
	        tbody.appendChild(tr);
	    });
	
	    await populateStylistSelects();
	}
 	
    	async function populateStylistSelects() {
    	    const res = await fetch('/web/stylists');
    	    const stylists = await res.json();

    	    document.querySelectorAll('.assignStylist').forEach(sel => {
    	        sel.innerHTML = '<option value="">Select</option>';
    	        stylists.forEach(s => {
    	            const o = document.createElement('option');
    	            o.value = s.userId;
    	            o.textContent = s.firstName;
    	            sel.appendChild(o);
    	        });
    	    });
    	}
    	
    	document.addEventListener('click', async e => {
    	    if (!e.target.classList.contains('startWalkIn')) return;

    	    const id = e.target.dataset.id;
    	    const select = e.target.closest('tr').querySelector('.assignStylist');
    	    const stylistId = select.value;

    	    if (!stylistId) {
    	        alert('Select a stylist first');
    	        return;
    	    }

    	    const res = await fetch(
    	        `/walkins/${id}/start?stylistId=${stylistId}`,
    	        {
    	            method: 'POST',
    	            headers: { [csrfHeader]: csrfToken }
    	        }
    	    );

    	    if (!res.ok) {
    	        alert('Unable to start walk-in');
    	        return;
    	    }

    	    calendar.refetchEvents();
    	    loadWalkInQueue();
    	});
    	async function openWalkInModal() {
    	    document.getElementById('walkInModal').style.display = 'flex';
    	    renderServicesForWalkIn(state.serviceCache);
    	}

    	function renderServicesForWalkIn(categories) {
    	    const container = document.getElementById('walkInServiceList');
    	    container.innerHTML = '';
    	    state.walkInServices = [];

    	    categories.forEach(c =>
    	        c.services.forEach(s => {
    	            const btn = document.createElement('button');
    	            btn.className = 'service-btn';
    	            btn.textContent = `${s.name} (${s.typicalDurationMinutes} min)`;

    	            btn.onclick = () => {
    	                btn.classList.toggle('selected');
    	                if (btn.classList.contains('selected')) {
    	                    state.walkInServices.push(s.serviceId);
    	                } else {
    	                    state.walkInServices =
    	                        state.walkInServices.filter(id => id !== s.serviceId);
    	                }
    	            };
    	            container.appendChild(btn);
    	        })
    	    );
    	}
    	
    	document.getElementById('walkInSaveBtn').onclick = async () => {
    	    if (state.walkInServices.length === 0) {
    	        alert('Select at least one service');
    	        return;
    	    }

    	    await fetch('/walkins/create', {
    	        method: 'POST',
    	        headers: {
    	            'Content-Type': 'application/json',
    	            [csrfHeader]: csrfToken
    	        },
    	        body: JSON.stringify({
    	            customerId: null,
    	            services: state.walkInServices.map(id => ({ serviceId: id }))
    	        })

    	    });

    	    document.getElementById('walkInModal').style.display = 'none';
    	    loadWalkInQueue();
    	};
    	
    	const emailInput = document.getElementById('walkInEmail');
    	const resultsBox = document.getElementById('walkInSearchResults');
    	let selectedCustomerId = null;

    	emailInput.addEventListener('input', async () => {
    	  const q = emailInput.value.trim();
    	  if (q.length < 2) return;

    	  const res = await fetch(`/customers/search?q=${encodeURIComponent(q)}`);
    	  const customers = await res.json();

    	  resultsBox.innerHTML = '';
    	  customers.forEach(c => {
    	    const div = document.createElement('div');
    	    div.textContent = `${c.email} (${c.firstName} ${c.lastName})`;
    	    div.onclick = () => {
    	      emailInput.value = c.email;
    	      selectedCustomerId = c.customerId;
    	      resultsBox.innerHTML = '';
    	    };
    	    resultsBox.appendChild(div);
    	  });
    	});




    
=======
>>>>>>> parent of f810f2c (Semi-working walk-ins)
    
    // ========================================
    // EVENT LISTENERS
    // ========================================
    
    // New Appointment Button
    document.getElementById('newApptBtn').addEventListener('click', openCreateModal);
    
    // Edit Modal Buttons
    document.getElementById('saveBtn').addEventListener('click', handleSaveEdit);
    document.getElementById('deleteBtn').addEventListener('click', handleDeleteAppointment);
    document.getElementById('closeBtn').addEventListener('click', closeEditModal);
    
    // Create Modal Buttons
    document.getElementById('createSaveBtn').addEventListener('click', handleCreateAppointment);
    document.getElementById('createCancelBtn').addEventListener('click', closeCreateModal);
    
    // Modal Click Outside
    document.getElementById('appointmentModal').addEventListener('click', (e) => {
        if (e.target.id === 'appointmentModal') closeEditModal();
    });
    
    document.getElementById('createModal').addEventListener('click', (e) => {
        if (e.target.id === 'createModal') closeCreateModal();
    });
    
    //Editing the time
    const modalStartInput = document.getElementById('modalStart');
	modalStartInput.addEventListener('change', recomputeEditEndFromStart);
	modalStartInput.addEventListener('input', recomputeEditEndFromStart);

<<<<<<< HEAD
    //Walk-In Buttons
    document.getElementById('newWalkInBtn')
	    .addEventListener('click', openWalkInModal);
	
	document.getElementById('walkInCancelBtn')
	    .addEventListener('click', () =>
	        document.getElementById('walkInModal').style.display = 'none'
	    );
	document.getElementById('walkInReturning').addEventListener('change', e => {
		  const isReturning = e.target.value === 'yes';

	document.getElementById('walkInExisting').style.display =
		    isReturning ? 'block' : 'none';

	document.getElementById('walkInNew').style.display =
		    e.target.value === 'no' ? 'block' : 'none';
		});
	
	document.getElementById('walkInSaveBtn').onclick = async () => {
		  if (state.walkInServices.length === 0) {
		    alert('Select at least one service');
		    return;
		  }

		  const returning = document.getElementById('walkInReturning').value;

		  let payload = {
		    services: state.walkInServices.map(id => ({ serviceId: id }))
		  };

		  if (returning === 'yes') {
		    if (!selectedCustomerId) {
		      alert('Select an existing customer');
		      return;
		    }
		    payload.customerId = selectedCustomerId;
		  }

		  if (returning === 'no') {
		    payload.newCustomer = {
		      email: document.getElementById('walkInNewEmail').value,
		      firstName: document.getElementById('walkInFirstName').value,
		      lastName: document.getElementById('walkInLastName').value,
		      phone: document.getElementById('walkInPhone').value
		    };
		  }

		  await fetch('/walkins/create', {
		    method: 'POST',
		    headers: {
		      'Content-Type': 'application/json',
		      [csrfHeader]: csrfToken
		    },
		    body: JSON.stringify(payload)
		  });

		  document.getElementById('walkInModal').style.display = 'none';
		  loadWalkInQueue();
		};



=======
    
>>>>>>> parent of f810f2c (Semi-working walk-ins)
    
    // ========================================
    // INITIALIZATION
    // ========================================
    
    setupCustomerSearch();
    await loadServiceCache();
    calendar.render();
});
</script>

<!-- Edit Modal -->
<div id="appointmentModal" class="modal-overlay" style="display:none;">
    <div class="modal-card glass-card">
        <h3 id="modalTitle"></h3>
        
        <div class="field-group">
            <label>Services</label>
            <div id="editServiceList"></div>
        </div>
        
        <div class="field-group">
            <label>Start</label>
            <input type="datetime-local" id="modalStart">
        </div>
        
        <div class="field-group">
            <label>End</label>
            <input type="datetime-local" id="modalEnd" disabled>
        </div>
        
        <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
            <button id="saveBtn" class="btn-primary" type="button">Save</button>
            <button id="deleteBtn" class="btn-danger" type="button">Delete</button>
            <button id="closeBtn" class="btn-secondary" type="button">Close</button>
        </div>
    </div>
</div>

<!-- Create Modal -->
<div id="createModal" class="modal-overlay" style="display:none;">
    <div class="modal-card glass-card">
        <h3>New Appointment</h3>
        
        <div class="field-group">
            <label>Services</label>
            <div id="serviceList"></div>
        </div>
        
        <div class="field-group">
            <label>Stylist</label>
            <select id="createStylist">
                <option value="">Select stylist</option>
            </select>
        </div>
        
        <div class="field-group" style="position:relative;">
            <label>Customer Email</label>
            <input type="email" id="customerEmail" placeholder="Search or enter email" autocomplete="off">
            <div id="customerSearchResults" style="position:absolute; top:100%; left:0; right:0; background:white; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,.15); z-index:1000; display:none; max-height:180px; overflow-y:auto;"></div>
        </div>
        
        <div class="field-group">
            <label>First Name</label>
            <input type="text" id="guestFirstName">
        </div>
        
        <div class="field-group">
            <label>Last Name</label>
            <input type="text" id="guestLastName">
        </div>
        
        <div class="field-group">
            <label>Phone</label>
            <input type="text" id="guestPhone">
        </div>
        
        <div class="field-group">
            <label>Start</label>
            <input type="datetime-local" id="createStart">
        </div>
        
        <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
            <button id="createSaveBtn" class="btn-primary" type="button">Create</button>
            <button id="createCancelBtn" class="btn-secondary" type="button">Cancel</button>
        </div>
    </div>
</div>

</body>
</html>