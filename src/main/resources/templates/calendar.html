<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <title>Salon Calendar</title>
    <link rel="stylesheet" href="/css/lilliputSalon.css" />

    <style>
        #calendar {
            max-width: 1100px;
            margin: 20px auto;
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: var(--glass-shadow);
        }
    </style>
</head>

<body class="page-gradient">

<header>
    <div th:replace="~{fragments/owner-nav :: ownerNav}"></div>
</header>

<main>
    <h2 style="text-align:center; margin: 20px 0;">Salon Calendar</h2>
    <div id="availabilityToggles"
	     style="max-width:1100px;margin:10px auto;">
	  <strong>Show availability:</strong>
	</div>
    
    <div id="calendar"></div>
</main>

<!-- FullCalendar Script -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.9/index.global.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
	
	let availabilityTogglesBuilt = false;
	
	const stylistVisibility = {};

    const calendarEl = document.getElementById('calendar');

    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',

        headerToolbar: {
            left:   'prev,next today',
            center: 'title',
            right:  'dayGridMonth,timeGridWeek,timeGridDay'
        },

        businessHours: [
            { daysOfWeek: [1,2,3,4,5], startTime: '09:00', endTime: '19:00' },
            { daysOfWeek: [6], startTime: '09:00', endTime: '17:00' }
        ],

        slotMinTime: '09:00:00',
        slotMaxTime: '19:00:00',

        editable: true,
        droppable: true,
        eventResizableFromStart: true,
        eventDurationEditable: true,

        eventSources: [

            // Appointments (already color-coded by backend)
            {
                url: '/calendar/events'
            },

            // Shifts (availability)
            {
            	  url: '/calendar/shifts',
            	  editable: false,
            	  success(events) {
            	    if (!availabilityTogglesBuilt) {
            	      buildAvailabilityToggles(events);
            	      availabilityTogglesBuilt = true;
            	    }
            	  }
            	}



        ],
        
        eventDidMount(info) {
            const props = info.event.extendedProps;

            // reset in case FC reuses DOM nodes
            info.el.style.display = '';

            if (props?.type === 'shift' || props?.type === 'break') {
              if (stylistVisibility[props.stylistId] === false) {
                info.el.style.display = 'none';
              }
            }
          },

        eventTextColor: 'black',

        eventDrop(info) {
            updateEvent(info);
        },
        eventResize(info) {
            updateEvent(info);
        },
        eventClick(info) {
            window.location.href = "/appointments/view/" + info.event.id;
        }
    });
    
    function buildAvailabilityToggles(events) {
    	  const container = document.getElementById('availabilityToggles');
    	  container.innerHTML = '<strong>Show availability:</strong>';

    	  const seen = new Set();

    	  // ðŸ”‘ FIRST PASS: initialize visibility
    	  events.forEach(e => {
    	    const sid = e.extendedProps?.stylistId;
    	    if (!sid) return;

    	    if (stylistVisibility[sid] === undefined) {
    	      stylistVisibility[sid] = false; // default = hidden
    	    }
    	  });

    	  // ðŸ”‘ SECOND PASS: build checkboxes
    	  events.forEach(e => {
    	    const props = e.extendedProps;
    	    const sid = props?.stylistId;
    	    if (!sid || seen.has(sid)) return;

    	    seen.add(sid);

    	    const label = document.createElement('label');
    	    label.style.marginRight = '12px';

    	    const cb = document.createElement('input');
    	    cb.type = 'checkbox';
    	    cb.checked = false; // ðŸ”¥ force unchecked on load

    	    cb.addEventListener('change', () => {
    	      stylistVisibility[sid] = cb.checked;
    	      calendar.refetchEvents();
    	    });

    	    label.appendChild(cb);
    	    label.append(` ${props.stylistName}`);
    	    container.appendChild(label);
    	  });
    	}



    function updateEvent(info) {
        fetch('/calendar/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: info.event.id,
                start: info.event.start.toISOString(),
                end: info.event.end ? info.event.end.toISOString() : null
            })
        })
        .then(res => res.json())
        .then(data => {
            if (data.status !== "ok") {
                alert(data.message || "Move rejected");
                info.revert();
            }
        })
        .catch(err => {
            console.error(err);
            alert("Server error");
            info.revert();
        });
    }


    calendar.render();
});
</script>


</body>
</html>
